// copyright (c) 2020 Roberto Ceccarelli - CasaSoft
// http://strawberryfield.altervista.org 
// 
// This file is part of CasaSoft BBS
// 
// CasaSoft BBS is free software: 
// you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// CasaSoft BBS is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
// See the GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with CasaSoft BBS.  
// If not, see <http://www.gnu.org/licenses/>.

using Casasoft.TextHelpers;
using System.Collections.Generic;
using System.Text;

namespace Casasoft.Fidonet
{
    /// <summary>
    /// Body of the message with echomail extensions
    /// </summary>
    /// <remarks>
    /// <see cref="http://ftsc.org/docs/fts-0004.001"/>
    /// <see cref="http://ftsc.org/docs/fts-0009.001"/>
    /// </remarks>
    public class MsgText
    {
        #region properties

        /// <summary>
        /// Echomail area
        /// </summary>
        /// <remarks>
        /// <para>
        /// This is  the first  line of  a conference  mail message. Its
        /// actual appearance is:
        /// </para>
        /// <example>AREA:CONFERENCE</example>
        /// <para>
        /// Where CONFERENCE is the name of the conference.This line is
        /// added when  a conference  is  being  "Exported"  to another
        /// system.It  is based upon information found in the AREAS.BBS
        /// configuration) File  for the designated message area.This
        /// field is  REQUIRED by  the receiving  system to  "Import"  a
        /// message into the correct Conference Mail area.
        /// </para>
        /// </remarks>
        public string Area { get; set; }

        /// <summary>
        /// Echomail Tear Line
        /// </summary>
        /// <remarks>
        /// <para>
        /// This line is near the end of a message and consists of three
        /// dashes (---)  followed by  an  optional  program  specifier.
        /// This is  used to show the first program used to add Echomail
        /// compatible control information to the message. The tear line
        /// generated by Conference Mail looks like:
        /// </para>
        /// <example>--- a small product-specific banner</example>
        /// <para>
        /// This  field   is  optional   for  most  Echomail  compatible
        /// processors, and  is added  by the  Conference Mail System to
        /// ensure complete  compatibility. Some systems will place this
        /// line in  the message  when it  is first  created, but  it is
        /// normally added when the message is first "exported."
        /// </para>
        /// </remarks>
        public string Tear { get; set; }

        /// <summary>
        /// Origin of the message
        /// </summary>
        /// <remarks>
        /// <para>
        /// This line  appears near  the bottom of a message and gives a
        /// small amount  of  information  about  the  system  where  it
        /// originated. It looks like:
        /// </para>
        /// <example>* Origin: The Conference Mail BBS (1:132/101)</example>
        /// <para>
        /// The "  * Origin:  " part  of the  line is  a constant field.
        /// This is followed by the name of the system.  The  complete
        /// network address  (1:132/101 in  this case)  is added  by the
        /// program inserting  the line.  This field is generated at the
        /// same time  as the  tear line,  and therefore  may either  be
        /// generated at  the time  of  creation  or  during  the  first
        /// "export"  processing.   Although  the  Origin  line  is  not
        /// required by  all Echomail  processors, it  is added  by  the
        /// Conference Mail System to ensure complete compatibility.
        /// </para>
        /// </remarks>
        public string Origin { get; set; }

        /// <summary>
        /// Seen-by lines
        /// </summary>
        /// <remarks>
        /// <para>
        /// There can  be many  seen-by lines  at the  end of Conference
        /// Mail messages,  and they  are the real "meat" of the control
        /// information. They  are used  to  determine  the  systems  to
        /// receive the exported messages. The format of the line is:
        /// </para>
        /// <example>SEEN-BY: 132/101 113 136/601 1014/1</example>
        /// <para>
        /// The net/node  numbers correspond  to the net/node numbers of
        /// the systems having already received the message. In this way
        /// a message  is never  sent to a system twice. In a conference
        /// with many  participants the  number of  seen-by lines can be
        /// very large.   This line is added if it is not already a part
        /// of the  message, or added to if it already exists, each time
        /// a message  is exported  to other systems. This is a REQUIRED
        /// field, and  Conference Mail  will not  function correctly if
        /// this field  is not put in place by other Echomail compatible
        /// programs.
        /// </para>
        /// </remarks>
        public List<string> SeenBy { get; set; }

        /// <summary>
        /// Path lines
        /// </summary>
        /// <remarks>
        /// <para>
        /// These are  the last  lines in  a Conference Mail message and
        /// are a  new addition,  and therefore  is not supported by all
        /// Echomail processors. It appears as follows:
        /// </para>
        /// <example>^aPATH: 132/101 1014/1</example>
        /// <para>
        /// Where the  ^a stands  for Control-A  (ASCII character 1) and
        /// the net/nodes  listed correspond  to  those  systems  having
        /// processed the  message before it reached the current system.
        /// This is  not the  same as  the seen-by  lines, because those
        /// lines list  all systems  the message has been sent to, while
        /// the path line contains all systems having actually processed
        /// the message.  This is not a required field, and few echomail
        /// processors currently  support it,  however it  can  be  used
        /// safely with  any other  system, since  the line(s)  will  be
        /// ignored.
        /// </para>
        /// </remarks>
        public List<string> Path { get; set; }

        /// <summary>
        /// Fidonet message id
        /// </summary>
        /// <remarks>
        /// <para>
        /// A MSGID line consists of the string "^AMSGID:" (where ^A is a
        /// control-A (hex 01) and the double-quotes are not part of the
        /// string),  followed by a space,  the address of the originating
        /// system,  and a serial number unique to that message on the
        /// originating system,  i.e.:
        /// </para>
        /// <example>^AMSGID: origaddr serialno</example>
        /// <para>
        /// The originating address should be specified in a form that
        /// constitutes a valid return address for the originating network.   
        /// If the originating address is enclosed in double-quotes,  the
        /// entire string between the beginning and ending double-quotes is 
        /// considered to be the orginating address.  A double-quote character
        /// within a quoted address is represented by by two consecutive
        /// double-quote characters.  The serial number may be any eight
        /// character hexadecimal number,  as long as it is unique - no two
        /// messages from a given system may have the same serial number
        /// within a three years.  The manner in which this serial number is
        /// generated is left to the implementor.
        /// </para>
        /// </remarks>
        public string MsgId { get; set; }

        /// <summary>
        /// Replay to Fidonet message id
        /// </summary>
        /// <remarks>
        /// <para>
        /// A REPLY line consists of the string "^AREPLY:" (where ^A is a
        /// control-A (hex 01) and the double-quotes are not part of the
        /// string),  followed by a space, and the origaddr and serialno
        /// fields of the MSGID line of the message to which this message is a
        /// reply,  i.e.:
        /// </para>
        /// <example>^AREPLY: origaddr serialno</example>
        /// <para>
        /// The origaddr and serialno fields must be identical to the
        /// corresponding fields in the MSGID of the message to which this
        /// message is a reply.  A REPLY line is never generated in a 
        /// message that is a reply to a message that does not contain a
        /// MSGID line.
        /// </para>
        /// </remarks>
        public string ReplyId { get; set; }

        /// <summary>
        /// Main text lines
        /// </summary>
        public List<string> Lines { get; set; }
        #endregion

        #region constructors
        public MsgText()
        {
            Area = string.Empty;
            Tear = string.Empty;
            Origin = string.Empty;
            SeenBy = new List<string>();
            Path = new List<string>();
            MsgId = string.Empty;
            ReplyId = string.Empty;
            Lines = new List<string>();
        }

        public MsgText(string s) : this()
        {
            Lines = TextHelper.SplitString(s);

            int f = Lines.FindIndex(s => s.StartsWith("AREA:"));
            if (f >= 0)
            {
                Area = Lines[f].Substring(5).Trim();
                Lines.RemoveAt(f);
            }

            f = Lines.FindLastIndex(s => s.StartsWith("--- "));
            if (f >= 0)
            {
                Tear = Lines[f].Substring(4).Trim();
                Lines.RemoveAt(f);
            }

            f = Lines.FindIndex(s => s.Trim().StartsWith("* Origin: "));
            if (f >= 0)
            {
                Origin = Lines[f].Trim().Substring(9).Trim();
                Lines.RemoveAt(f);
            }

            f = Lines.FindIndex(s => s.StartsWith("\u0001MSGID: "));
            if (f >= 0)
            {
                MsgId = Lines[f].Substring(7).Trim();
                Lines.RemoveAt(f);
            }

            f = Lines.FindIndex(s => s.StartsWith("\u0001REPLY: "));
            if (f >= 0)
            {
                ReplyId = Lines[f].Substring(7).Trim();
                Lines.RemoveAt(f);
            }

            f = Lines.FindIndex(s => s.StartsWith("SEEN-BY: "));
            while (f >= 0)
            {
                SeenBy.Add(Lines[f].Substring(8).Trim());
                Lines.RemoveAt(f);
                f = Lines.FindIndex(s => s.StartsWith("SEEN-BY: "));
            }

            f = Lines.FindIndex(s => s.StartsWith("\u0001PATH: "));
            while (f >= 0)
            {
                Path.Add(Lines[f].Substring(6).Trim());
                Lines.RemoveAt(f);
                f = Lines.FindIndex(s => s.StartsWith("\u0001PATH: "));
            }
        }
        #endregion

        /// <summary>
        /// Returns message body in string
        /// </summary>
        public string Text
        {
            get
            {
                StringBuilder sb = new StringBuilder();

                if (!string.IsNullOrWhiteSpace(Area)) sb.Append($"AREA:{Area}\n");
                if (!string.IsNullOrWhiteSpace(MsgId)) sb.Append($"\u0001MSGID: {MsgId}\n");
                if (!string.IsNullOrWhiteSpace(ReplyId)) sb.Append($"\u0001REPLY: {ReplyId}\n");

                foreach (string s in Lines) sb.Append(s + "\n");

                if (!string.IsNullOrWhiteSpace(Tear)) sb.Append($"--- {Tear}\n");
                if (!string.IsNullOrWhiteSpace(Origin)) sb.Append($" * Origin: {Origin}\n");

                foreach (string s in SeenBy) sb.Append($"SEEN-BY {s}\n");
                foreach (string s in Path) sb.Append($"\u0001PATH {s}\n");

                return sb.ToString();
            }
        }
    }
}
